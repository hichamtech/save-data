'use strict';

// excluding regex trick: http://www.rexegg.com/regex-best-trick.html
// Not anything inside double quotes
// Not anything inside single quotes
// Not anything inside url()
// Any digit followed by px
// !singlequotes|!doublequotes|!url()|pixelunit
const remRegex = /"[^"]+"|'[^']+'|url\([^)]+\)|var\([^)]+\)|(\d*\.?\d+)rem/g;

/* eslint-disable no-useless-escape */
function exact(list) {
    return list.filter((m) => {
        return m.match(/^[^\*\!]+$/);
    });
}
function contain(list) {
    return list
        .filter(function (m) {
        return m.match(/^\*.+\*$/);
    })
        .map(function (m) {
        return m.slice(1, m.length - 1);
    });
}
function endWith(list) {
    return list
        .filter(function (m) {
        return m.match(/^\*[^\*]+$/);
    })
        .map(function (m) {
        return m.slice(1);
    });
}
function startWith(list) {
    return list
        .filter(function (m) {
        return m.match(/^[^\*\!]+\*$/);
    })
        .map(function (m) {
        return m.slice(0, m.length - 1);
    });
}
function notExact(list) {
    return list
        .filter(function (m) {
        return m.match(/^\![^\*].*$/);
    })
        .map(function (m) {
        return m.slice(1);
    });
}
function notContain(list) {
    return list
        .filter(function (m) {
        return m.match(/^\!\*.+\*$/);
    })
        .map(function (m) {
        return m.slice(2, m.length - 1);
    });
}
function notEndWith(list) {
    return list
        .filter(function (m) {
        return m.match(/^\!\*[^\*]+$/);
    })
        .map(function (m) {
        return m.slice(2);
    });
}
function notStartWith(list) {
    return list
        .filter(function (m) {
        return m.match(/^\![^\*]+\*$/);
    })
        .map(function (m) {
        return m.slice(1, m.length - 1);
    });
}

function isObject(val) {
  return val !== null && typeof val === "object";
}
function _defu(baseObj, defaults, namespace = ".", merger) {
  if (!isObject(defaults)) {
    return _defu(baseObj, {}, namespace, merger);
  }
  const obj = Object.assign({}, defaults);
  for (const key in baseObj) {
    if (key === "__proto__" || key === "constructor") {
      continue;
    }
    const val = baseObj[key];
    if (val === null || val === void 0) {
      continue;
    }
    if (merger && merger(obj, key, val, namespace)) {
      continue;
    }
    if (Array.isArray(val) && Array.isArray(obj[key])) {
      obj[key] = val.concat(obj[key]);
    } else if (isObject(val) && isObject(obj[key])) {
      obj[key] = _defu(val, obj[key], (namespace ? `${namespace}.` : "") + key.toString(), merger);
    } else {
      obj[key] = val;
    }
  }
  return obj;
}
function createDefu(merger) {
  return (...args) => args.reduce((p, c) => _defu(p, c, "", merger), {});
}
const defu = createDefu();

const defaultOptions = {
    rootValue: 16,
    unitPrecision: 5,
    selectorBlackList: [],
    propList: ['font', 'font-size', 'line-height', 'letter-spacing'],
    replace: true,
    mediaQuery: false,
    minRemValue: 0,
    exclude: /node_modules/i,
    transformUnit: 'px'
};

const postcssPlugin = 'postcss-rem-to-responsive-pixel';
function getConfig(options) {
    if (typeof options === 'undefined') {
        throw new Error(`${postcssPlugin} plugin does not have the correct options`);
    }
    return defu(options, defaultOptions);
}
function createRemReplace(rootValue, unitPrecision, minRemValue, transformUnit = 'px') {
    return function (m, $1) {
        if (!$1)
            return m;
        const rems = parseFloat($1);
        if (rems < minRemValue)
            return m;
        const fixedVal = toFixed(rems * rootValue, unitPrecision);
        return fixedVal === 0 ? '0' : fixedVal + transformUnit;
    };
}
function toFixed(number, precision) {
    const multiplier = Math.pow(10, precision + 1);
    const wholeNumber = Math.floor(number * multiplier);
    return (Math.round(wholeNumber / 10) * 10) / multiplier;
}
function declarationExists(decls, prop, value) {
    // @ts-ignore
    return decls.some((decl) => decl.prop === prop && decl.value === value);
}
function blacklistedSelector(blacklist, selector) {
    if (typeof selector !== 'string')
        return;
    return blacklist.some((regex) => {
        if (typeof regex === 'string') {
            return selector.indexOf(regex) !== -1;
        }
        return selector.match(regex);
    });
}
function createPropListMatcher(propList) {
    const hasWild = propList.indexOf('*') > -1;
    const matchAll = hasWild && propList.length === 1;
    const lists = {
        exact: exact(propList),
        contain: contain(propList),
        startWith: startWith(propList),
        endWith: endWith(propList),
        notExact: notExact(propList),
        notContain: notContain(propList),
        notStartWith: notStartWith(propList),
        notEndWith: notEndWith(propList)
    };
    return function (prop) {
        if (matchAll)
            return true;
        return ((hasWild ||
            lists.exact.indexOf(prop) > -1 ||
            lists.contain.some(function (m) {
                return prop.indexOf(m) > -1;
            }) ||
            lists.startWith.some(function (m) {
                return prop.indexOf(m) === 0;
            }) ||
            lists.endWith.some(function (m) {
                return prop.indexOf(m) === prop.length - m.length;
            })) &&
            !(lists.notExact.indexOf(prop) > -1 ||
                lists.notContain.some(function (m) {
                    return prop.indexOf(m) > -1;
                }) ||
                lists.notStartWith.some(function (m) {
                    return prop.indexOf(m) === 0;
                }) ||
                lists.notEndWith.some(function (m) {
                    return prop.indexOf(m) === prop.length - m.length;
                })));
    };
}

exports.blacklistedSelector = blacklistedSelector;
exports.createPropListMatcher = createPropListMatcher;
exports.createRemReplace = createRemReplace;
exports.declarationExists = declarationExists;
exports.getConfig = getConfig;
exports.postcssPlugin = postcssPlugin;
exports.remRegex = remRegex;
